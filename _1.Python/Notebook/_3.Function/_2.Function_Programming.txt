二.函数式编程
1.函数式编程
        是指用一系列函数来解决问题
        函数是基本单位,常用用lambda表达式来配合编程
        函数是一等公民,在编程过程中占据较为重要的地位
    说明:
        用每一个函数完成细小的功能,一系列函数的任何组成可以解决大问题
        函数仅接受输入并产生输出,不包含任何可能影响输出的内部状态
        函数尽量小而通用,每个函数都有自己独特的功能,尽量写小的函数
2,函数的可重入性:
        当一个函数没有访问除局部变量以外的变量和数据,则此函数是可重入函数
        可重入函数在同样的条件和数据进入后得到的数据是唯一不变的
        写函数时尽量避免有全局变量,尽量使用可重入函数
    示例:
        #可重入函数
        def myadd1(x,y):
            return x+y
        #不可重入函数
        s=0
        def myadd2(x,y):
            global s
            s += x + y
            return x + y
3.高阶函数
    定义:
        满足下列条件中的一个函数即为高阶函数
            1)函数接受一个或多个函数作为参数传入
            2)函数返回一个函数
    python内建的高阶函数
        1)map(func,*iterrables)
                返回可迭代对象,此可迭代对象用func对可迭代对象iterrables中的
                每个元素作为参数计算后得到结果,再返回,当最短的一个可迭代对象
                不再提供数据时迭代结束
            示例:
                1.map.py
                2.map_pow.py
            练习:
                3.exe_sum.py
                4.exe_sum.py
                5.exe_sum.py
        2)filter 函数
                filter(func,iterable) 返回一个可迭代对象,此可迭代对象将对iterrable获取到的数据用函数
                func进行筛选,func将对iterable中的每个元素进行求值,返回False则丢弃,返回True则保留此数据
          示例:
                6.filter.py

        3)sorted 函数
            作用:
                将原可迭代对象的数据进行排序,生成排序后的列表
            格式:
                sorted(iterable,key=None,reverse=False)
            说明:
                iterable 是可迭代对象
                key 函数是用来提供比较值的数据,这个值将作用排序的依据
                reverse 标志用来设置是否降序排列
                排序排的是原来的数据
            示例:
                8.sorted.py
            练习：
                ９．exe_sorted.py
        还有reduce,apply等 在functiontools模块中
4.递归函数
        函数直接或间接的调用自身
    示例:
        #直接调用自己
        def f1():
            f1()  #直接调用自己
        f1()
        #间接调用自己
        def fb():
            fa()   #间接调用自己
        fa()
    示例2:
        11.recursion.py
    说明:
        递归一定要控制递归的层数,当符合一定条件时要终止递归调用
        几乎所有的递归都能用while循环来代替
    优缺点:
        优点:
            把问题简单化,让思路更加的清晰,代码更简洁
        缺点:
            因系统环境影响大,当递归深度太大时,可能会得到不可预知的结果
    递归函数调用分为两个阶段:
        1.递推阶段
            从原问题出发,按递归公式递推从未知到已知,最终
            达到递归终止条件
        2.回归阶段
            按递归终止条件求出结果,逆向逐渐代入递归公式,回归原问题求解
5.闭包 closure
    定义:
        闭包是引用了此函数外部变量的函数
        动态的创建类似函数的功能
        闭包可能会占用较大的内存
    需满足的三个条件;
        1.必须有内嵌函数
        2.内嵌函数必须引用外部函数中的变量
        3.外部函数返回值必须是内嵌函数
    示例:
        14.closure.py

6.装饰器 decorator
    作用:
        装饰函数时使用,在不改变函数的情况下增加原函数的功能
    定义:
        装饰器是一个函数,能常用来包装另一个函数或类
  函数装饰器:
        是指装饰器函数,传入的是函数,返回的也是函数
    语法:
        def 装饰器函数名(形参):
            语句块
            return 函数对象
        @装饰器函数名
        def 函数名(形参列表):
            语句块
    示例:
        1.mydecol1.py
        2.mydecol1.py
        3.mydecol1.py
    函数的文档字符串
    函数内第一次未赋值给任何变量的字符串是函数的文档字符串
    语法:
        def 函数名(参数列表)
        "函数的文档字符串"
        函数语句块
    示例:
        def cba():
            """这是一个文档字符串,
            以下省略300字"""
            pass
        >>> help(cba)
7.函数的_doc_属性
        _doc_属性用于记录函数的文档字符串
    如:
        print(cba._doc_)
  函数定义语句的完整用法:
    [@装饰名1]
    [@装饰名2]
    [...]
    def 函数名([位置形参],[*元组形参],[命名关键字形参],[**字典形参])
    "文档字符串"
    语句块
  面试题:
    L=[1,2]
    def f(n,lst=None):   #缺省参数最好不要加可变类型如[],可能会出问题
        """lst绑定的列表会在def语句创建时创建,且和f绑定的函数一同存在"""
        if lst is None:
            lst = []     #此解决办法是官方推荐的,将该函数变的可重入
        lst.append(n)
        print(lst)
    f(3,[])
    