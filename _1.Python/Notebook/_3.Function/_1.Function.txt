一.函数
1.基本介绍
        函数是可以重复执行的语句块,可以重复调用
        是面向过程编码的最小基本单位,最主要单位
    作用:
        1.用于封装语句块,提高代码的重用性
        2.定义用户级别的函数
2.def语句
    语法:
        def 函数名(形参列表):
            语句块
    说明:
        1).函数的名字就是语句块的名称
        2).函数的命名规则与变量名的规则相同(必须是标识符)
        3).函数名是一个变量(不要轻易对其赋值)
        4).函数名有自己的名字空间,在函数外部不能访问函数内部的变量
           在函数内部可以访问外部的变量(但是尽量不要让内部访问全局变量)
            要让函数处理内部的数据最好用参数给函数传入一些数据
        5).函数如果不需要传入参数,参数列表可为空
        6).语句部分不能为空,如果为空要填充pass语句
    函数调用:
        函数名(实际是调用传递参数)
        说明:
            函数调用是一个表达式,如果函数内没有return语句,则默认返回None
        示例1:
            def say_hello():
                print("hello world")
                print("hello Tarena")
                print("hello everyone")
            say_hello()  #调用一次say_hello
        示例2:
            #此示例示意写一个函数,此函数的功能是给他两个数据,让它把最大值的
            数据打印出来
            #def mymax(a,b):
                if b>m:
                    m=b
                print("最大值数据是:",m)
            mymax(100,200)
            # r= myadd(100,200) 返回None,
            # 因为如果函数内没有return语句,则默认返回None
3.return语句
    语法:
        return [表达式]
        注释:[] 代表其中的内容可省略
    作用:
        用于函数中,结束当前函数的执行,返回到调用函数的地方,
        同时返回一个对象的引用关系
    说明:
        1.return语句后跟着的表达式可省略,省略后相当于return 返回None
        2.如果函数内没有return语句,则函数执行完最后一条语句后返回None
        (相当于在最后加了一条return None语句)
    示例:
        见2.return.py
3.函数的参数
        1)函数调用实际传递参数
            传递的信息是给,即是输入,把数据给函数
        2)函数的形式参数
            从调用者拿来(接收)数据
4.函数的实际调用参数传递
    1)传递方式:
        a.位置传参
            实际参数(实参)的对应关系与形式参数(形参)的对应关系
            是按位置来依次对应的
          示例:
            def mymin(a,b,c):
                pass  ^ ^ ^
            mymin(    1,2,3)
            示例见:
                8.position_give_args.py
            说明:实参个数与形参个数相同
          序列传参:
            序列:字符串,列表,元组
            序列传参是指在函数调用过程中,
            用*(星号)将序列拆解后按位置进行传递的传参方式
            示例:  
                9.sequence_give_args.py
            说明:
                序列传参时,序列拆解的位置与形参一一对应
                序列的位置信息对应的
        b.关键字传参
            是指传参时,按着形参的名称给形参赋值
            实参和形参按名称进行匹配
            示例见:
                10.keywords_give_args.py
            说明:
                实参和形参可以不按位置进行匹配
          字典关键字传参
            是指实参为字典,将字典用**(双星号)拆解后进行关键字传参
            的传参方式
            示例见:
                11.dict_keywords_give_args.py
            说明:
                字典的键名必须跟形参名一致
                字典的键名必须是字符串,且必须是标识符的命名规则
                字典的键名要在形参中存在
        c.函数综合传参
            函数的传参方式,在能够确定形参能唯一匹配到相应的实参
            的情况下可以任意组合,函数的位置传参要先于关键字传参
            示例:
                1.函数的位置传参和序列传参可以混合使用,可以顺序颠倒
                    myfun1(100,*[200,300])
                    myfun1(*[100,200],300)
                    myfun1(*[100],200,*[300])
                2.函数位置传参和关键字传参可以混合使用
                    myfun1(100,c=200,b=300)
                    myfun1(100,**{c=200},b=300)
5.函数的形参
    函数的缺省参数
        语法:
            def 函数名(形参名1=默认实参1,形参名2=默认实参2,...):
                语句块
        示例:
            12.default_args.py
        说明:
            1)缺省参数必须自右向左依次存在,如果一个参数有缺省参数,则其右侧的
            所有参数都必须有缺省参数
            2)缺省参数可以有0个1个或多个,甚至全部都是缺省参数
            3)Python 函数在定义的时候，默认参数 L 的值就被计算出来了，
            即 [] ，因为默认参数 L 也是一个变量，
            它指向对象 [] ，每次调用该函数，如果改
            变了 L 的内容，则下次调用时，默认参数的内容就变了，
            不再是函数定义时的 [] 了。
            所以，定义默认参数要牢记一点：默认参数必须指向不变对象！
            为什么要设计 str 、 None 这样的不变对象呢？因为不变对象一旦创建，
            对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误
            此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读
            一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那
            就尽量设计成不变对象
    函数形参的定义方式
        1).位置形参
            语法:
                def 函数名(形参名1,形参名2,....):
                    语句块
        2).星号元组形参
            语法:
                def 函数名(*元组形参名):
                    语句块
            作用:
                收集多余的位置传参
            说明:
                元组形参一般命名为"args"
            示例:
                14.star_tuple_args.py
        3).命名关键字形参
            语法:
                def 函数名(*,命令关键字形参1,命名关键字形参2.....):
                    语句块.....
              或:
            作用:
                强制所有的命名关键字形参都必须用关键字传参或字典关键字
                传参
            示例:
                见18.named_keywords_args.py
        4).双星号字典形参
            语法:
                def 函数名(**字典形参名)
                    语句块
            作用:
                收集多余的关键字传参
            说明:
                字典形参名一般为"kwargs"
            示例:
                17.dict_keywords_args.py
    函数的参数说明:
            位置形参,星号元组形参,命名关键字形参,双星号形参,缺省参数
            都可以混合使用
        函数参数从左到右的顺序为:
            位置形参
            星号元组形参
            命名关键字形参
            双星号字典形参
        示例:
            def fx(a,b,*args,c,d,**kwargs):
                pass
            fx(1,2,3,4,5,c="C",d="D",e="E")
        #可以接收任意的位置传参和关键字传参的函数;
            def fn(*args,**kwargs):
                print(args)
                print(kwargs)
            fn(1,2,3,4,*(abcd),**{"a":1},c=3)
        查看>>>help(print)
           >>>range()
6.全局变量和局部变量
    局部变量:
        定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
        局部变量只能在函数内部使用
        局部变量咋函数调用时才能够被创建,在调用之后自动销毁
        在实际工作中,要多用局部变量,少用全局变量
    全局变量:
        定义在函数外部,模块文件内部的变量称为全局变量,
        所有的函数都可以直接访问,但不能在直接将其赋值
        局部变量在函数调用结束后销毁
    示例:
        20.global_local.py
    说明:
        在函数内部的赋值语句会创建局部变量,不会对全局变量造成影响
        局部变量只能在其被声明的函数内部访问.
        而全局变量可以在整数模块范围内访问
7.globals() 和 locals()函数
    globals()  返回当前全局作用域内变量的字典
    locals()  返回当前局部作用域内变量的字典
  示例:
    21.global_local.py
8.函数作为变量
        函数名是变量名,他在创建时绑定一个函数
        算法是指处理一些事情的顺序,逻辑及方法
    示例:
        26.function_variable.py
        27.function_variable2.py
9.一个函数可以作为另一个函数的实参传递
    示例:
        28.function_as_args.py
        29.function_as_args2.py
10.函数作为另一个函数的返回值
    示例:
        30.return_function.py
11.函数的嵌套定义:
    函数嵌套定义是指一个函数用def语句来创建其他函数的情况
    示例:
        31.function_embed.py
12.python中变量的作用域
        作用域也叫命名空间,是访问变量时查找变量名的范围空间
    python的四个作用域:
        作用域:
            局部作用域     Local      
            外部嵌套函数作用域     Enclosing function  local
            函数定义所在模块作用域  Global
            python内建模块的作用域 Builtins(Python)
        示例 32.namespace.py
13.变量名的查找规则
    在访问变量的时候,先查找本地变量,然后是包裹此函数外部的函数内部的
    变量,之后是全局变量,最后是内建变量,即:
    L L  --> E --> G  --> B
    在默认的情况下,变量名赋值会创建或者改变本地作用域的变量
14.global语句
    作用: 
        告诉解释执行器,golbal语句声明的一个或多个变量,这个变量的作用域为模块级
        作用域,也称为全局变量,全局声明将赋值语句的变量映射到模块内部的作用域
    语法:
        global 变量1,变量2...
    示例:
        34.global.py
    说明:
        1.全局变量如要在函数内部被赋值,则必须经过全局声明,
          否则被认为是局部变量
        2.全局变量在函数内部不经过全局声明就可以访问(取值)
        3.不能先声明局部变量再用golbal声明为全局变量,此做法不符合规则
        4.global变量列表里的变量名不能出现在函数的形参列表里
15.nonlocal语句
    作用:
        告诉解释执行器,nonlocal声明的变量不是局部变量,也不是全局变量,
        而是外部嵌套函数内的变量
    语法:
        nonlocal 变量名1,变量名2....
    示例:
        37.nonlocal.py
    说明:
        1.nonlocal语句只能在嵌套函数内部进行使用,
        2.对nonlocal变量列表内的变量赋值将对外部嵌套函数
          作用域内的变量进行操作
        3.当有两层或以上的嵌套函数时,访问nonlocal变量只对
          最近的一层的变量进行操作
        4.nonlocal语句变量列表里的变量名,不能出现在此函数的形参列表里
16.lambda表达式
    作用:
        创建一个匿名函数对象,同def类似,但是不提供函数名
    语法:
        lambda[函数名形参列表]:表达式
    示例:
        38.lambda.py
    说明:
        lambda表达式创建的函数只能包含一条表达式且直接
        返回表达式的值
        该函数比较简单,且可以随时创建和销毁,有利于减少函数的耦合度
17.eval() 和 exec()函数
    作用:
        把一个字符串当成表达式(不能放语句)来执行,返回表达式执行后的结果
    格式:
        eval(source,global=None,local=None)
        (注:eval函数输出的值为局部local的值)
    示例:
        s="1+2*3"
        v=eval(s)  # v=7
        print(v)   #7
        示例:41.eval.py
    应用场景:
            从网上下载的东西大部分是字符串,可用eval()可对其使用
   exec:
    作用:
        把一个字符串当成一个程序来执行
    格式:
        exec(source,global=None,local=None)
    示例:
        s="x=100\ny=200\nprint("x+y=",x+y)"
        exec(s)
    示例2:
        s="print('x+y=',x+y,'x*y=',x*y)"
        exec(s,{"x":10,"y":20},{"y":2})
        #取值时以局部优先,若局部无值,再从全局变量中取值
        x+y=12,x*y=20

