多任务编程
    意义
        充分利用计算机资源提高程序的运行效率
    定义
        通过一定的编程手段,在一个程序运行中可以同时利用计算机执行多个任务,以此提高程序运行效率
    实现方案
        多进程
        多线程
    并发
        可以接受多个任务,内核在任务间不断的切换达到好像多个任务被同等执行的效果,实际每个时刻只有一个任务占有内核
    并行
        多个任务利用计算机多核资源同时执行,此时多个任务间为并行关系
进程 Process
    定义
        程序在计算机中运行的一次过程
    程序
        是一个可执行文件,是静态的占有磁盘空间
    进程
        进程是一个动态的过程,占有计算机资源,有一定的生命周期
    进程的诞生
        用户空间通过程序接口或者命令发起起进程创建请求
        操作系统接受用户请求,开始创建进程
        操作系统分配计算机资源,确定进程状态,开辟空间等
        操作系统将创建的进程提供给用户使用
    一些概念
        cpu时间片:
            如果一个进程占有cpu内核则称这个进程在cpu时间片上
        PCB(进程控制块)
            在内存中开辟的一块空间存放进程的基本信息
        进程ID:PID
            系统为进程分配的ID号,每个进程不重复
                查看命令 ps -aux
        父子进程
            系统中每一个进程,都有唯一的父进程,可能有多个的子进程,形成父子进程的关系
            查看命令 pstree
        进程状态
            三种状态
                就绪态
                    当进程创建后首先进入就绪态,具备执行条件,等待系统分配cpu资源
                运行态
                    进程占有cpu时间片正在运行
                等待态
                    等待时不占用系统资源,进程暂时不具备执行条件
            五种状态
                新建态
                    创建一个新的进程,获取资源的过程
                就绪
                执行
                等待
                终止
                    进程结束,系统资源被系统回收
            查看命令
                ps -aux ----->STAT列第一个字母
                    S       等待态      可中断的等待
                    D       等待态      不可中断的等待态,或者等待某结束命令
                    T       等待态      暂停
                    R       运行态
                    Z       僵尸进程
                第二个字母
                    < 有较高的优先级
                    N 较低的优先级
                    + 前台进程
                    s 会话组组长
                    l 有链接子进程的
            进程优先级
                作用
                    决定进程的优先权限和占有资源的优先程度
                查看命令
                    top   动态查看系统进程的优先级,NI栏
                linux优先级范围
                   -20 -- 19
                    数越小,优先级越高
                指定优先级运行程序
                    nice -9 python3 while.py   以9的优先级运行
                    nice --9 python3 while.py  以-9的优先级运行
                    0以下的优先级可能需要超级权限sudo
            进程的特征
                进程可以使用计算机的多核资源
                进程是计算机分配系统资源的最小单位
                进程之间互不影响,各自独立运行
                每个进程的空间独立,各占有自己的空间资源
多进程编程   
    import os
    id = os.fork()
    功能
        创建新的进程
    参数
        无
    返回值
        失败     返回负数
        成功     在原进程返回新进程的PID号
                在新进程中返回0
    注意:
        1.子进程会父子父进程的全部代码段和内存空间
        2.子进程从fork下一句开始执行
        3.if elif else结构判断frok返回值不同从而使父子进程执行不同的代码几乎是固定搭配
        4.父子进程各自独立运行,运行顺序不一定
        5.子进程有自己特有的内容:PID 进程控制块,命令集等
        6.子进程的fork语句前的赋值语句/表达式等皆有效,但是一些执行语句不能够执行,
          因为子进程完全复制了父进程的全部代码段和内存空间
        7.进入阻塞状态的进程一定会让出cpu时间片
        8.各个进程在自己的空间内对数据的操作不影响其他进程
        9.父进程在执行fork之前开辟的空间子进程也会复制
    进程创建注意:
        如果父进程创建对象后,创建子进程,子进程从父进程获取对象,此时父子进程在对象操作上有一定的互相影响
           例:
            套接字对象监听相同的端口,文件对象会使用同一个偏移量,
            如果父进程先创建子进程,则父子进程各自产生的对象没有任何的关系
进程相关函数
    os.getpid()
        功能        获取当前进程的pid号
        返回值      返回当前进程的pid
    os.getppid()
        功能        获取父进程的PID
        返回值      返回父进程的PID
    os._exit(status)
        功能:       退出进程
        参数        整数   表示自定义的进程退出状态标志
    sys.exit([status])
        功能:       退出进程
        参数:       整数  表示退出状态  默认为0
                   传一个字符串,则退出时会打印该字符串
孤儿进程和僵尸进程
    孤儿进程:
        父进程先于子进程退出,此时子进程会称为孤儿进程
        孤儿进程会被系统进程收养,此时系统进程会成为该进程的新的父进程
        一旦成为孤儿进程,不会再成为僵尸进程
    僵尸进程
            子进程先于父进程退出,父进程没有处理子进程退出状态,此时子进程会成为僵尸进程
            僵尸进程虽然结束会存留部分的PCB在内存,大量的僵尸进程会占用内存资源
        如何避免僵尸进程产生
            方法1
                处理子进程退出状态
                    pid,status = os.wait()
                        pid         退出的子进程PID
                        status       子进程的退出状态  

            方法2
                pid,status = os.waitpid(pid,option)
                    功能    在父进程中等待子进程退出
                    参数    pid -1 表示等待任意子进程
                                >0 等待指定PID的子进程退出
                            option 0 表示阻塞等待
                                    WNOHANG 表示非阻塞
                    返回值
                            pid         退出的子进程PID
                            status       子进程的退出状态   
            方法3
                创建二级子进程
                    父进程创建子进程等待子进程退出
                    子进程再创建二级子进程然后退出
                    二级子进程成为孤儿进程
                    和原来父进程各执行任务
            示例:
                _5,_6
编程步骤
    了解需求.细分需求的功能
    示例:
    确认技术模型
        如何将客户端的信息发给所有人能看到
            利用服务端转发,服务器接收,然后转发给其他人
        用哪种服务器
            udp,因为简单很多
        用户存储
            要存姓名地址,采用字典{name:ip}
        发送和接收互不干扰
            发送和接收用不同的进程分别处理发送接收
    整体设计
        封装
            将每个功能封装成函数
        测试
            实现一个功能,测试一个功能
        编写流程
            搭建网络连接,然后进行逐个功能的实现
        细化流程,
            建立流程图,将需要的功能有条不紊的实现
小知识
    在函数内部对外部传入的可变数据类型进行修改,则外部的该变量会发生改变
    示例:
        L = [1,2,3]
        def fun(l):
            l.append(4)
        fun(L)
        print(L)
        # 得返回值L=[1,2,3,4]

MultiProcessing 模块创建进程
        将需要执行的进程事件封装为函数
        使用模块的process类生成进程对象,并关联相应函数
        可以通过对象属性设置进程信息
        启动进程,此时会自动运行绑定的函数,作为一个进程来执行
        回收进程
    process()
        功能 
            创建进程对象
        参数
            target  必写参数  绑定的目标函数
            name    可选参数  给进程起名字,默认为Process-1
            args    元组  给target目标函数按照位置传参
            kwargs  字典  给target目标函数按照键值传参
    start()
        功能 启动进程
        target 绑定的函数开始执行,进程真正创建

    p.join([timeout])
        功能
            阻塞等待回收进程
        参数
            timeout   超过时间
    注意:
        使用MultiProcessing创建进程,同样子进程复制父进程的全部空间代码段,父子进程互不影响,各自有各自的运行空间
        不使用join回收子进程会成为僵尸进程
        MultiProcessing父进程玩玩只用来管理子进程的创建和回收,具体事件由子进程完成
    进程对象属性
        p.name       进程名称
        p.pid        进程的pid号
        p.daemon   
            默认为False 表示主进程退出不会影响子进程的运行
            如果设置为True  此时主进程退出子进程也会退出
            注意:
                要在start 之前设置,且不和join一起使用
        p.is_alive()   查看进程的生命周期
    示例:
        _11
自定义进程类
    定义
        继承process类
        编写自己的__init__添加自己的属性
        使用super重新加载父类的__init__方法
        重写run方法
        使用自己的类创建进程对象,调用start启动进程,此时会自动执行run方法
        调用join()回收进程
    示例:
        _12
多进程的一些问题
    优点: 
        可以使用计算机的多核运行多个任务,提高了运行效率
    缺点: 
        进程创建删除需要消耗的系统资源较多
进程池技术(爬虫相关会用到)
    产生原因
        如果有大量任务需要多进程完成,则可能要频繁的的创建删除进程
        此时给计算机带来的压力较大
    原理:
        创建一定数量的进程作为进程池,用来处理事件,时间处理完毕后不销毁事件,而是继续等待处理其他的事件,
        直到所有的待处理时间结束后再统一销毁进程,这样增加进程的重复利用,降低资源消耗
    使用方法
        创建进程池,方法适当的进程
        将要做的事件放入进程池等待队列
        不断取事件使用进程池中进程执行,直到所有事件处理完毕
        关闭进程池,回收进程
    模块
        from MultiProcessing import Pool
            功能  创建进程池对象
            参数  指定进程池中进程的数据量,默认根据系统自动判定

        (异步执行)pool.apply_async(func,args,kwds)
            可以同时进行执行
            功能   使用进程池中的进程执行相应函数
            参数
                func   进程事件函数
                args   元组   给func按位置传参
                kwds   字典   给func按关键字传参
            返回值:
                返回函数事件对象

        (较少使用)pool.apply(func,args,kwds)
            同步执行,一个执行完再执行下一个
            功能   使用进程池中的进程执行相应函数
            参数
                func   进程事件函数
                args   元组   给func按位置传参
                kwds   字典   给func按关键字传参

        pool.close()
            功能    关闭进程池,不能再添加新的事件

        pool.join()
            功能    阻塞等待回收进程池进程
                等所有的进程都运行完了,自动回收所有进程
        pool.map(func,iter)
            功能  将要做的事件加入进程池
            参数  迭代对象
            返回值  函数值的返回列表
    示例
        _13
进程间通信(IPC)
    原因    
        进程空间相对独立,资源无法互相获取,此时在不同进程间需要专门的方法进行通信
    进程间通信  
        管道   消息队列   共享内存     信号   信号量     套接字
    通信管道
        通信原理
            在内存当中开辟管道空间.生成管道操作对象,
            多个进程使用同一个管道对象进行读写即可实现通信
    模块
        管道Pipe
            from multiprocessing import Pipe
            fd1,fd2 = Pipe(duplex = True)
            功能:
                创建管道
            参数
                默认为双向管道
                如果设置为False,则为单向管道
            返回值
                表示管道两端的读写对象
                如果是双向管道则两端都可以读写
                如果是单向管道则fd1只能读(recv),fd2只能写(send)
            fd.recv()
                功能  
                    从管道读取内容
                返回值 
                    读到的内容
                *当管道为空的时候则阻塞
            fd.send()
                功能
                    向管道写入内容
                参数
                    要写入的数据
                * 可以写入python的数据类型
            示例
                _15
        消息队列    
            队列
                先进先出
            原理
                在内存中建立队列模型,进程通过队列对象将消息存入队列
                或者从队列取出消息,完成进程间的通信
            示例:
                from multiprocessing import Queue
                q = Queue(maxsize = 0)
                    功能
                        创建队列对象
                    参数
                        表示队列中最多存放多少个消息
                    返回值
                        队列对象
                q.put(data,[block,timeout])
                    功能
                        向队列存入消息
                    参数
                        data     要存入的内容,python数据
                        block    阻塞,默认状态满时会阻塞,设置为False则为非阻塞
                        timeout  超时检测 
                q.get([block,timeout])
                    功能
                        从队列获取消息
                    参数
                        block    默认当队列为空时阻塞,设置为False则为非阻塞
                        timeout  超时检测
                q.full()    判断队列是否为满
                q.empty()   判断队列是否为空
                q.qsize()   返回队列中消息的个数
                q.close()   关闭队列
        共享内存
            通信原理:
                在内存空间开辟一个区域,对多个进程可见,进程可以写入内容或者读取内容,
                但是每次写入会覆盖之前的内容
            实例详解
                from multiprocessing import Value,Array
                obj = Value(ctype,obj)      # 单一数据
                    功能     
                        开辟共享内存空间
                    参数     
                        ctype   字符串,表示共享内存中主要的存储的数据类型
                                常用类型: 
                                        int -->   "i"
                                         float  --> "f"
                                         char(bytes)   --> "c"           
                        obj    共享内存中放入的初始化数据
                                属性:
                                    obj.value  对该属性的修改和使用即对共享内存的修改和使用
            示例
                _18
                obj = Array(ctype,obj)    # 数据结构
                    功能:
                        创建共享内存
                    参数
                        ctype   要存储的数据类型
                        obj     存入一个结构化的数据(列表,bytes字符串)表示共享内存中的初始数据
                                传入正整数 则表示在共享内存中开辟指定大小的数据空间
                    返回值:
                        共享内存对象
                        *通过遍历获取每个值,支持索引操作
                        *可以通过obj.value直接打印整个字符串
                    示例:
                        obj[2]    表示获取共享内存中第三项,
        总结
                        管道                消息队列            共享内存
            开辟空间     内存                 内存                 内存
            读写方式     两端读写             先进先出              覆盖之前的内容
            效率        一般                 一般                 较高
            特点        多用于父子进程        有很多第三方队列        需要注意同步操作
        信号量(信号灯)
            原理
                给定一个数量,多个进程均可见.多个进程可以通过方法操作数量,达到协同工作的目的
            示例详解:
                from multiprocessing import Semaphore
                sem = Semaphore(num)
                功能        创建信号量对象
                参数        信号量的初始值
                返回值      信号量对象
            sem.acquire()     将信号量减1,当信号量为0 时会阻塞
            sem.release()     将信号量+1
            sem.get_value()   获取信号量数量
        示例:
            _20

            
                        
                

                        

